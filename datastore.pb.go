// Code generated by protoc-gen-go. DO NOT EDIT.
// source: datastore.proto

/*
Package datastore is a generated protocol buffer package.

It is generated from these files:
	datastore.proto

It has these top-level messages:
	WriteRequest
	WriteResponse
	ReadRequest
	EncryptedEvent
	ReadResponse
	DeleteRequest
	DeleteResponse
*/
package datastore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// WriteRequest is the message that is sent to the store in order to write
// data. Data is written keyed by the public key of the recipient, the id of
// the user, as well as an id representing the entitlement policy. Finally the
// encrypted data is sent as a chunk of bytes.
type WriteRequest struct {
	// The public key is the key identifying the party for which data has been
	// encrypted.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// The user uid is a unique identifier for the user submitting the data. We
	// persist this in order to allow the user to delete stored data.
	UserUid string `protobuf:"bytes,2,opt,name=user_uid,json=userUid" json:"user_uid,omitempty"`
	// The data field here is the encrypted data to be stored for the specified
	// public key/entitlement policy. From the datastore's perspective this can
	// just be a slice of bytes, however zenroom does permit this data to maintain
	// some structure.
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *WriteRequest) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *WriteRequest) GetUserUid() string {
	if m != nil {
		return m.UserUid
	}
	return ""
}

func (m *WriteRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// WriteResponse is a placeholder message returned from the call to write data
// to the store. Currently no fields have been identified, but keeping this as
// a separate type allows us to add fields as we identify them.
type WriteResponse struct {
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// ReadRequest is the message that is sent to the store in order to read data
// for a specific bucket. When requesting data a client must submit the public
// key and entitlement policy id which identify the bucket, then optional start
// and end timestamps. If the time attributes are included then the end time
// must be after the start time; if no end time is specified then the default is
// "now". It is an error to specify an end time without a start time.
type ReadRequest struct {
	// The public key is the key identifying the party for which data has been
	// encrypted. This field is required.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// The start time represents the start of an interval for which we wish to read
	// data. This field is optional, but if nil end_time must also be nil. It is
	// an error for start_time to be after end_time.
	StartTime *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// The end time represents the end of an interval for which we wish to read
	// data. It may be nil, in which case it defaults to "now".
	EndTime *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// The page cursor is an opaque string that an implementing server can
	// understand in order to efficiently paginate through events.  The value
	// sent here cannot be calculated by the client, rather they should just
	// inspect value returned from a previous call to to `ReadData` and if this a
	// non-empty string, then this value can be sent back to the server to get
	// the "next" page of results.
	// This field is optional.
	PageCursor string `protobuf:"bytes,4,opt,name=page_cursor,json=pageCursor" json:"page_cursor,omitempty"`
	// The maximum number of encrypted events to return in the response. The
	// default value is 500.
	PageSize uint32 `protobuf:"varint,5,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ReadRequest) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *ReadRequest) GetStartTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ReadRequest) GetEndTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *ReadRequest) GetPageCursor() string {
	if m != nil {
		return m.PageCursor
	}
	return ""
}

func (m *ReadRequest) GetPageSize() uint32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// EncryptedEvent is a message representing a single instance of encrypted data
// that is stored by the datastore. When reading data we return lists of this
// type, which comprise a timestamp and a chunk of encoded data. From the
// datastore's perspective the encrypted data can be viewed as just an opaque
// chunk of bytes, however our encoding engine (Zenroom), does allow us to just
// encrypt the values within a JSON structure, but for the datastore's purposes
// we don't care about this.
type EncryptedEvent struct {
	// The time at which the event was recorded by the datastore.
	EventTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=event_time,json=eventTime" json:"event_time,omitempty"`
	// The opaque chunk of bytes comprising the encoded data from the device.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// An identifier for an individual event. Used internally when sorting and
	// paginating.
	EventId int64 `protobuf:"varint,3,opt,name=event_id,json=eventId" json:"event_id,omitempty"`
}

func (m *EncryptedEvent) Reset()                    { *m = EncryptedEvent{} }
func (m *EncryptedEvent) String() string            { return proto.CompactTextString(m) }
func (*EncryptedEvent) ProtoMessage()               {}
func (*EncryptedEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EncryptedEvent) GetEventTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.EventTime
	}
	return nil
}

func (m *EncryptedEvent) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EncryptedEvent) GetEventId() int64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

// ReadResponse is the top level message returned by the read operations to the
// datastore. It contains the public key for the recipient, as well as the
// entitlement policy id. The events property contains a list of encrypted
// events in ascending time order. This will not necessarily be all possible
// events for the requested time period, as we have implemented pagination for
// this endpoint. If the response contains a non-empty string for the
// next_page_cursor property, then there are more pages of data to be consumed;
// if this property is the empty string, then the response is all data available
// for the requested time period.
type ReadResponse struct {
	// The public key of the recipient for which data is being requested. This
	// field will always have a non-empty value.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// The list of encrypted events containing the actual data being requested.
	// This list will be returned in ascending time order, and each element
	// contains a timestamp as well as the actual chunk of encrypted data. If no
	// data is available this will be an empty list.
	Events []*EncryptedEvent `protobuf:"bytes,2,rep,name=events" json:"events,omitempty"`
	// An optional field containing a pointer to the next page of results
	// expressed as an opaque string. Clients should not expect to be able to
	// parse this string as its contents are strictly implementation specific and
	// subject to change at any time. Rather the value here should just be checked
	// to see if it is an empty string or contains a value, and if any value is
	// present, the client can pass it back in a new read request as the value of
	// the page_cursor field.
	NextPageCursor string `protobuf:"bytes,3,opt,name=next_page_cursor,json=nextPageCursor" json:"next_page_cursor,omitempty"`
	// The page size that was originally requested to create this response.
	// Supplied to make it easy for the client to construct a new request for the
	// next page.
	PageSize uint32 `protobuf:"varint,4,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (m *ReadResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ReadResponse) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *ReadResponse) GetEvents() []*EncryptedEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *ReadResponse) GetNextPageCursor() string {
	if m != nil {
		return m.NextPageCursor
	}
	return ""
}

func (m *ReadResponse) GetPageSize() uint32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// DeleteRequest is a message that is sent to the server in order to delete
// entries stored for a particular user. It may be in the future we extend this
// to allow data for a specific entitlement policy to be deleted but for now the
// only use case we know we have to support is being able to delete an
// individual user's data.
type DeleteRequest struct {
	// The public key is the key identifying the party for which data has been
	// encrypted. This field is required.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// The id of the user who wishes to have their data removed from the datastore.
	UserUid string `protobuf:"bytes,2,opt,name=user_uid,json=userUid" json:"user_uid,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DeleteRequest) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *DeleteRequest) GetUserUid() string {
	if m != nil {
		return m.UserUid
	}
	return ""
}

// DeleteResponse is a placeholder message we return from the delete call.
// Future implementations may add fields to this type.
type DeleteResponse struct {
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func init() {
	proto.RegisterType((*WriteRequest)(nil), "decode.thingful.datastore.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "decode.thingful.datastore.WriteResponse")
	proto.RegisterType((*ReadRequest)(nil), "decode.thingful.datastore.ReadRequest")
	proto.RegisterType((*EncryptedEvent)(nil), "decode.thingful.datastore.EncryptedEvent")
	proto.RegisterType((*ReadResponse)(nil), "decode.thingful.datastore.ReadResponse")
	proto.RegisterType((*DeleteRequest)(nil), "decode.thingful.datastore.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "decode.thingful.datastore.DeleteResponse")
}

func init() { proto.RegisterFile("datastore.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 471 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x95, 0xe3, 0xd0, 0xc4, 0xe3, 0x24, 0xad, 0xf6, 0xe4, 0x1a, 0xa1, 0x46, 0x3e, 0x50, 0xf7,
	0xe2, 0x4a, 0x41, 0x1c, 0x38, 0x02, 0xed, 0xa1, 0xe2, 0x82, 0x0c, 0x08, 0x09, 0x10, 0x96, 0x93,
	0x9d, 0x86, 0x15, 0xa9, 0x6d, 0x76, 0xd7, 0x88, 0xe4, 0x97, 0xf8, 0x00, 0x7e, 0x86, 0x8f, 0x41,
	0x3b, 0x6b, 0x97, 0x14, 0xa9, 0x71, 0x0e, 0xdc, 0xbc, 0xb3, 0xef, 0xbd, 0x99, 0xf7, 0x3c, 0x0b,
	0x87, 0x3c, 0xd7, 0xb9, 0xd2, 0xa5, 0xc4, 0xa4, 0x92, 0xa5, 0x2e, 0xd9, 0x31, 0xc7, 0x45, 0xc9,
	0x31, 0xd1, 0x5f, 0x44, 0xb1, 0xbc, 0xae, 0x57, 0xc9, 0x2d, 0x20, 0x3c, 0x59, 0x96, 0xe5, 0x72,
	0x85, 0xe7, 0x04, 0x9c, 0xd7, 0xd7, 0xe7, 0x5a, 0xdc, 0xa0, 0xd2, 0xf9, 0x4d, 0x65, 0xb9, 0xd1,
	0x27, 0x18, 0xbd, 0x97, 0x42, 0x63, 0x8a, 0xdf, 0x6a, 0x54, 0x9a, 0x3d, 0x02, 0xa8, 0xea, 0xf9,
	0x4a, 0x2c, 0xb2, 0xaf, 0xb8, 0x0e, 0x9c, 0xa9, 0x13, 0x7b, 0xa9, 0x67, 0x2b, 0xaf, 0x70, 0xcd,
	0x8e, 0x61, 0x58, 0x2b, 0x94, 0x59, 0x2d, 0x78, 0xd0, 0xa3, 0xcb, 0x81, 0x39, 0xbf, 0x13, 0x9c,
	0x31, 0xe8, 0x9b, 0xbe, 0x81, 0x3b, 0x75, 0xe2, 0x51, 0x4a, 0xdf, 0xd1, 0x21, 0x8c, 0x1b, 0x75,
	0x55, 0x95, 0x85, 0xc2, 0xe8, 0xb7, 0x03, 0x7e, 0x8a, 0x39, 0xdf, 0xb3, 0xdd, 0x33, 0x00, 0xa5,
	0x73, 0xa9, 0x33, 0x33, 0x36, 0x35, 0xf4, 0x67, 0x61, 0x62, 0x3d, 0x25, 0xad, 0xa7, 0xe4, 0x6d,
	0xeb, 0x29, 0xf5, 0x08, 0x6d, 0xce, 0xec, 0x29, 0x0c, 0xb1, 0xe0, 0x96, 0xe8, 0x76, 0x12, 0x07,
	0x58, 0x70, 0xa2, 0x9d, 0x80, 0x5f, 0xe5, 0x4b, 0xcc, 0x16, 0xb5, 0x54, 0xa5, 0x0c, 0xfa, 0x34,
	0x11, 0x98, 0xd2, 0x4b, 0xaa, 0xb0, 0x87, 0xe0, 0x11, 0x40, 0x89, 0x0d, 0x06, 0x0f, 0xa6, 0x4e,
	0x3c, 0x4e, 0x87, 0xa6, 0xf0, 0x46, 0x6c, 0x30, 0xda, 0xc0, 0xe4, 0xb2, 0x58, 0xc8, 0x75, 0xa5,
	0x91, 0x5f, 0x7e, 0xc7, 0x42, 0x1b, 0x07, 0x68, 0x3e, 0xec, 0x20, 0x4e, 0xb7, 0x03, 0x42, 0xd3,
	0x28, 0x6d, 0xa0, 0xbd, 0xbf, 0x81, 0x9a, 0xfc, 0xad, 0x9c, 0xe0, 0xe4, 0xca, 0x4d, 0x07, 0x74,
	0xbe, 0xe2, 0xd1, 0x2f, 0x07, 0x46, 0x36, 0x5a, 0x9b, 0x75, 0x57, 0xb6, 0xcf, 0xe1, 0x80, 0xa8,
	0x2a, 0xe8, 0x4d, 0xdd, 0xd8, 0x9f, 0x9d, 0x25, 0xf7, 0xae, 0x51, 0x72, 0xd7, 0x54, 0xda, 0x10,
	0x59, 0x0c, 0x47, 0x05, 0xfe, 0xd0, 0xd9, 0x76, 0x62, 0x2e, 0xf5, 0x99, 0x98, 0xfa, 0xeb, 0x7b,
	0x52, 0xeb, 0xff, 0x93, 0xda, 0x15, 0x8c, 0x2f, 0x70, 0x85, 0xff, 0x61, 0x09, 0xa3, 0x23, 0x98,
	0xb4, 0x52, 0x36, 0x85, 0xd9, 0xcf, 0x1e, 0x78, 0x17, 0xad, 0x11, 0xf6, 0x19, 0x3c, 0x5a, 0x48,
	0x53, 0x61, 0xa7, 0x3b, 0x1c, 0x6f, 0x3f, 0x8a, 0x30, 0xee, 0x06, 0x36, 0x99, 0x7f, 0x84, 0xa1,
	0xf9, 0x07, 0x24, 0xff, 0x78, 0x07, 0x6b, 0xeb, 0x0d, 0x84, 0xa7, 0x9d, 0xb8, 0x46, 0x3c, 0x07,
	0xb0, 0xe6, 0x48, 0x7e, 0xd7, 0x50, 0x77, 0xe2, 0x0c, 0xcf, 0xf6, 0x40, 0xda, 0x16, 0x2f, 0xfc,
	0x0f, 0xde, 0xed, 0xdd, 0xfc, 0x80, 0xf6, 0xf3, 0xc9, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x63,
	0xbd, 0x3e, 0x3c, 0x71, 0x04, 0x00, 0x00,
}
